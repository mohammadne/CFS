# Namespaces

Namespaces make a process “believe” it has its own system.

Each namespace isolates a different OS resource:

```sh
docker run -d --privileged --name machine ubuntu:24.04 sleep 3600
docker exec -it machine bash

# --privileged -> Give extended privileges to this container

apt update
apt install -y util-linux procps
```

## PID Namespace — Process Tree Isolation

A PID namespace isolates process IDs between different environments (containers, sandboxes, or user-created namespaces using unshare).

Each PID namespace has:

- Its own init process (PID 1) as init
- Its own process table
- Its own signal handling hierarchy
- A mapping from child PID namespace → parent namespaces
- Processes inside container cannot see host processes
- Killing PID 1 inside container only restarts that container

This is why:

- A process may be PID 1 inside a container, but It could be PID 98765 on the host.
- This hierarchical PID tree is why containers behave as small isolated Linux systems.

### Demo

Terminal A → parent
Terminal B → child

```sh
# Parent (Terminal A)

# shows all PID namespaces existing on your machine
lsns -t pid
```

```sh
# Child

# the process-id of the current bash process
echo $$

# --pid: unshare the PID namespace.
# --mount-proc: mount the proc filesystem for correct PID visibility.
# --fork: fork the specified program as a child process of unshare.
# /bin/bash: run bash inside the new namespace
unshare --pid --mount-proc --fork /bin/bash

# the process-id of the current bash process
echo $$

sleep 2000 &
sleep 2100 &
sleep 2200 &

ps -ef
lsns -t pid
```

```sh
# Parent (Terminal A)

# shows all PID namespaces existing on your machine
lsns -t pid

ps -ef

# 171 1 (the bash process of the child)
car /prox/CHILD_BASH/status | grep NSpid
```

```sh
# Child
# Spawn a new namespace inside child
unshare -p --mount-proc -f sleep 3000 &
```

```sh
# Parent (Terminal A)

# shows all PID namespaces existing on your machine
lsns -t pid

ps -ef

# 226 8 1 (the bash process of the child) -> 3 PID level
car /prox/CHILD_BASH/status | grep NSpid
# also check the PIDs and PPIDs

# 3 PID namespaces
lsns -t pid
```

## UTS Namespace — Hostname/Domainname Isolation

UTS = UNIX Time-sharing System

- Every container gets its own hostname
- Allows different “virtual hosts” on one machine
- This is why hostname inside a container returns a container-specific value.

When Docker/podman creates a container, they ALWAYS create a new UTS namespace so the container has a unique hostname.

### Demo

Terminal A → parent
Terminal B → child

```sh
# Parent (Terminal A)

lsns -t uts
```

```sh
# Child (Terminal B)

hostname
hostname child-uts

# when you open a new bash, it inherits all the namespaces of its parent process.
bash

# verify
hostname
lsns -t uts
```

```sh
# Parent (Terminal A)

lsns -t uts
```

## IPC Namespace — Inter-Process Communication

Isolates:

| Mechanism      | Command               | Kernel object       |
| -------------- | --------------------- | ------------------- |
| Shared Memory  | `shmget` / `ipcmk -M` | `/proc/sysvipc/shm` |
| Message Queues | `msgget` / `ipcmk -Q` | `/proc/sysvipc/msg` |
| Semaphores     | `semget` / `ipcmk -S` | `/proc/sysvipc/sem` |

## Demo

```bash
# list IPC objects
ipcs

# ipcmk create IPC objects
ipcmk -M 10     # create a shared-memory segment of size 10 bytes
ipcmk -Q        # create a message queue

# list IPC objects
ipcs

sudo unshare --ipc /bin/bash

# list IPC objects on the new container
ipcs
exit

# list IPC objects again on the host
ipcs

cat /proc/sysvipc/shm
cat /proc/sysvipc/msg
cat /proc/sysvipc/sem
```

## MNT Namespace — Filesystem Mount Isolation

- Each container has its own mount table (isolated view of /)
- Allows mounting volumes inside the container without affecting the host
- Required for root filesystem layering (OverlayFS)

### Demo 1

```sh
# the device and partitions that kernel detects
# List block devices with mount points
lsblk

# List devices
ls /dev

# List available filesystem types
cat /proc/filesystems

# List currently mounted file systems (default format)
mount

# List mounted file systems with a better tree format
findmnt

# Report filesystem disk space usage
df -h

# Create a mount point
mkdir /mnt/16gb-usb

# Mount a device (replace /dev/sdb1 with your actual device)
mount /dev/sdb1 /mnt/16gb-usb

# Verify mount
mount | grep 16gb-usb

# Unmount
umount /mnt/16gb-usb
```

### Demo 2

```sh
# Terminal A

cd /tmp

# Download Alpine minirootfs
apt install curl -y
curl -O https://dl-cdn.alpinelinux.org/alpine/v3.23/releases/x86_64/alpine-minirootfs-3.23.0-x86_64.tar.gz

# Create Alpine rootfs directory
mkdir -p /tmp/alpine-rootfs

# Extract Alpine rootfs
tar xzvf alpine-minirootfs-3.23.0-x86_64.tar.gz -C /tmp/alpine-rootfs

# Optional: marker file to identify host rootfs
touch /tmp/alpine-rootfs/HOST_VM_ROOTFS
```

```sh
# Terminal B

unshare --uts --pid --fork chroot /tmp/alpine-rootfs /bin/sh
ls -lah
apt # not work
apk # works!

# Check processes — note /proc is host's by default
# not show anything, because proc of the new process is on /proc not the $HOME/proc
ps -ef

# change the pid space
# mount -t type device dir
#
# nosuid: Do not allow set-user-identifier or set-group-identifier bits to take effect
# nodev: Do not interpret character or block special devices on the file system
# noexec: Do not allow execution of any binaries on the mounted file system.

# Mount proc inside Alpine for correct PID view
mkdir -p ./proc
mount -t proc proc ./proc -o nosuid,nodev,noexec
```

```bash
# Terminal A

# check the proc
findmnt

umount $HOME/alpine-rootfs/proc
findmnt
```

```sh
# Terminal B

mount

mount -t proc proc ./proc -o nosuid,nodev,noexec

# remount part of the file hierarchy somewhere else
mkdir -p /mnt/test
mount --bind /usr/bin/ /mnt/test

# all binaries are here
ls -lah /mnt/test
```

```sh
# Terminal A

# /tmp/alpine-rootfs/mnt/test is also exists in Host
findmnt
mount

# we can see child namespace mount points take affect on the host
# so we have to use mount namespace
mount | grep alpine-rootfs
umount /tmp/alpine-rootfs/proc
umount /tmp/alpine-rootfs/mnt/test # or /mnt/test in child
mount | grep alpine-rootfs
```

```sh
# Terminal B

exit

# Use isolated mount namespace
# here we use --mount to seperate mount points of the processes inside the container
# also we can run this with --net (ip netns add)
unshare --uts --pid --mount --fork chroot /tmp/alpine-rootfs /bin/sh


mount
mount -t proc proc ./proc -o nosuid,nodev,noexec
mount

# remount part of the file hierarchy somewhere else
mkdir -p /mnt/test
mount --bind /usr/bin/ /mnt/test

mount
apk add findmnt
```

```sh
# Terminal A

mount

mount | grep alpine-rootfs
```

## Time Namespace

```sh
# Terminal A
date
```

```sh
# Terminal B

unshare --time --fork /bin/bash

date -s "1 hour"
date
```

```sh
# Terminal A
date
```

## USER Namespace — User & Permission Isolation

- Maps root inside container to non-root UID on host
- Enables rootless containers
- Major security improvement
- Example:
- Container root (UID 0) → host UID 1000.

```sh
# Terminal A

# get your current user information
id

lsns --type user
```

```sh
# Terminal B

# without remapping
unshare --user bash

# 56534 comes from /proc/sys/kernel/overflowuid
id
```

```sh
# Terminal A

# get your current user information
id

# get all user namespaces
lsns --type user
```

```bash
exit

# with remapping
unshare --map-root-user bash # unshare -Ur bash
id

# get remapping (ID-inside-ns ID-outside-ns range)

# $$ is the PID of the bash
cat /proc/$$/uid_map 

# the self refers to the cat command itself (ls -l /proc/self/exe)
# every time you run the ls command, you'll get a new process ID
cat /proc/self/uid_map 

# create a file
touch temp.txt
ls -l
```

```bash
# Terminal A

# get ubuntu user-id and group-id
sudo cat /etc/passwd | grep ubuntu

# permissions of temp.txt
ls -l
```

```bash
# Terminal B

exit
unshare --user bash
echo $$
```

```bash
# Terminal A

child_pid=38

# And not just UID 0 — you map a whole range:
# Inside UIDs 0–65334 map to host UIDs 1000–66334.
echo "0 1000 65335" | sudo tee /proc/$chold_pid/uid_map
echo "0 1000 65335" | sudo tee /proc/$chold_pid/gid_map
```

```bash
# Terminal B

cat /proc/$$/uid_map
cat /proc/$$/gid_map

touch hello
```

```bash
# Terminal A

ls -l hello
```

## NET Namespace — Network Isolation

- Isolates networking stack:
- Interfaces (eth0)
- IP addresses
- Routing tables
- iptables rules
- Ports, sockets
- Containers get virtual NICs (veth pairs) connected to a bridge (docker0).
