# Containers

## What Exactly Is a Container?

A single process (or a group of processes) running in an isolated environment created by the Linux kernel using namespaces, cgroups, and filesystem layers.

### Definition & core idea of “process-level isolation”

A container is:
> A single process (or a group of processes) running in an isolated environment created by the Linux kernel using namespaces, cgroups, and filesystem layers.

Key Concepts:

- A container is not a full OS — it shares the host’s Linux kernel.
- It sees a private environment:
  - Its own process list (PID namespace).
  - Its own hostname and network stack (UTS & NET namespaces).
  - Its own mount points and filesystem (MNT namespace).

- Resource usage (CPU, memory, IO) is restricted via cgroups.

Why this matters:

- Containers are extremely lightweight: no separate kernel or full OS image.
- Containers start in milliseconds.
- Multiple containers share the same machine safely without interfering.

### Difference between container and image

Image:
  > A static, read-only, packaged filesystem.

  Contains:

- Your application code
- System libraries
- Runtime dependencies (Python, Node, Go binaries, etc.)
- Configuration defaults

  An image is like a template or blueprint.

Container:
  > A running instance of an image.

  Has:

- A writable layer on top of the read-only image layers.
- A process running inside it (PID 1).
- Its own isolated environment.

Analogy:

- Image = class
- Container = object instance
  Or:
- Image = recipe
- Container = ready-to-eat dish

### Immutability & stateless deployment model

Immutability
Images are immutable:
Once built, they never change.
If you need to update something → build a new image tag.
This ensures deployments are predictable, repeatable, and versioned.

Statelessness
Containers should store no persistent data internally.

All data is externalized to:

- Volumes
- Databases
- Object storage

A container can be:

- Killed
- Restarted
- Recreated
- Scaled up/down
…without losing state.

Why immutability matters

- No accidental config drift.
- Easy rollbacks (just redeploy an old image).
- Perfect for autoscaling and cloud-native patterns.

### Why containers matter for DevOps

1. Consistent Environments

- Developer machine
- CI pipeline
- Staging
- Production
- Eliminates: “But it works on my machine!”

2. Fast CI/CD Integration

- Lightweight, reproducible build environments.
- Run tests inside containers.
- Build once → run anywhere.

3. Microservices Architecture

- Each service packaged independently.
- Scalable and loosely coupled systems.

4. Infrastructure as Code & Automation

- Dockerfiles define how to build the environment.
- No manual OS configuration needed.

5. High Density & Cost Efficiency

- More containers than VMs per node.
- Efficient resource usage → lower infrastructure cost.

6. Rapid Deployment

- Start in milliseconds.
- Roll out new versions quickly and safely.

## Containers vs VMs

### OS-level virtualization vs hardware virtualization

Virtual Machines:

- VMs virtualize hardware.
- They use a hypervisor (like VMware, Hyper-V, KVM) to emulate:
  - CPU
  - Memory
  - Network / IO devices
- Each VM runs its own full Operating System:
  - Kernel
  - System libraries
  - User-space processes

```txt
Physical Server
   ↓
Hypervisor
   ↓
VM1 (Full OS + Apps)
VM2 (Full OS + Apps)
VM3 (Full OS + Apps)
```

Containers

- Containers virtualize at the OS level, not hardware.
- Containers share the host kernel, using Linux primitives like:
  - Namespaces (isolation)
  - cgroups (resource limits)
  - UnionFS/OverlayFS (layered images)

```txt
Physical Server
  ↓
Host OS + Kernel
  ↓
Container Engine (Docker/containerd)
  ↓
App1 (isolated)
App2 (isolated)
App3 (isolated)
```

### Performance overhead comparison

VM Overhead

Because each VM has its own OS:

- Higher RAM usage
- More CPU overhead (hypervisor layer)
- Larger images (GBs)
- Slower I/O and system calls (virtualized hardware)

Container Overhead

Because containers reuse host kernel:

- Near-native performance (no hardware emulation)
- Very small memory footprint
- Very small disk footprint (tens or hundreds of MBs)
- System calls executed directly on host kernel

Benchmark Reality:

- Containers are usually 5–20x lighter than VMs.
- CPU performance is almost native (98–99%).
- I/O can be slightly slower (due to overlay filesystems), but still far faster than VM disks.

### Boot time, resource usage, density

VMs: 10–60 seconds (OS boot time)

Containers: <1 second (start process immediately)

### Hypervisor

> A hypervisor is software (or firmware) that allows multiple virtual machines (VMs) to run on a single physical machine by virtualizing the hardware.

It creates an environment where each VM believes it has:

- its own CPU
- its own memory
- its own storage
- its own network card

Two Types of Hypervisors

1. Type 1 Hypervisor (Bare-Metal Hypervisor)

> Runs directly on the hardware, no host OS beneath it.

Examples:

- VMware ESXi
- Microsoft Hyper-V
- Xen
- KVM (Linux Kernel-based Virtual Machine)

Characteristics:

- Highest performance
- Used in data centers / servers
- Better isolation and security

2. Type 2 Hypervisor (Hosted Hypervisor)

> Runs on top of an existing operating system.

Examples:

- VirtualBox
- VMware Workstation / Fusion

Characteristics:

- Easier to install and use
- Slightly slower (host OS overhead)
- Good for development, personal use

## Kernel Primitives

These are the Linux kernel features that make containers possible.

Docker did not invent containers — it combined these primitives into a usable system.

### Namespaces

Namespaces make a process “believe” it has its own system.

Each namespace isolates a different OS resource:

1. PID Namespace — Process Tree Isolation

- Each container gets its own PID 1 (init)
- Processes inside container cannot see host processes
- Killing PID 1 inside container only restarts that container

2. NET Namespace — Network Isolation

- Isolates networking stack:
- Interfaces (eth0)
- IP addresses
- Routing tables
- iptables rules
- Ports, sockets
- Containers get virtual NICs (veth pairs) connected to a bridge (docker0).

3. MNT Namespace — Filesystem Mount Isolation

- Each container has its own mount table (isolated view of /)
- Allows mounting volumes inside the container without affecting the host
- Required for root filesystem layering (OverlayFS)

4. IPC Namespace — Inter-Process Communication

Isolates:

- Shared memory segments
- Message queues
- Semaphores
- Prevents shared-memory leakage between containers.

5. UTS Namespace — Hostname/Domainname Isolation

- Every container gets its own hostname
- Allows different “virtual hosts” on one machine
- This is why hostname inside a container returns a container-specific value.

6. USER Namespace — User & Permission Isolation

- Maps root inside container to non-root UID on host
- Enables rootless containers
- Major security improvement
- Example:
- Container root (UID 0) → host UID 1000.

### CGroups

control groups, a kernel mechanism to limit, prioritize, and account for resources.

1. CPU Quotas & Shares
CPU quota: hard limit (0.5 = 50% CPU)
CPU shares: proportional scheduling between containers
Controls CPU starvation under load

2. Memory Limits & OOM Behavior
Memory max (hard limit)
Memory reservation (soft limit)
Swap limits
Kernel OOM killer terminates processes that exceed limits

3. I/O Throttling
Limit disk bandwidth:
Read/write bytes per second
IOPS control
Useful for preventing one container from saturating disk I/O.

#### cgroup v1 vs v2

cgroup v1:

- Multiple separate hierarchies
- Fragmented controllers
- Docker originally used this

cgroup v2:

- Unified hierarchy (single tree)
- Proper delegation & nested cgroups
- More consistent resource limits
- Better I/O and memory semantics
- Default on modern Linux (systemd)

### Copy-On-Write Behavior

If a container modifies a file:

- Original file stays in lower layer (read-only)
- A copy goes to the container’s upper layer
- Container writes only to upper layer

This makes:

- Images lightweight
- Containers fast to start
- Builds cacheable

How image layers work:

A Docker image is a stack of read-only layers:

```dockerfile
FROM alpine
RUN apk add curl
RUN adduser ...
```

- Each instruction → new layer.
- Container = image layers + writable layer.
