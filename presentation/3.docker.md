# Docker

## Installation

```sh
ansible-playbook playbook.yaml -i inventory.ini
```

## How Docker Works

Docker has a client-server architecture:

```txt
docker CLI (client)  →  Docker Daemon (dockerd)
```

- The CLI sends requests to dockerd via a Unix socket (/var/run/docker.sock)
- The server actually performs actions like pulling images, building, and running containers.

```sh
ls -l /var/run/docker.sock
```

When pulling an image, under the hood:

`CLI → dockerd → containerd → snapshotter → registry`

```sh
docker pull alpine:3.22.2

docker image inspect alpine:3.22.2 --format '{{json .RootFS.Layers}}' | jq
```

- Each layer = a snapshot in overlayfs
- Layers are cached → reused across containers

### Build, run, pull, push flow

```txt
fastapi
uvicorn
```

```python
from fastapi import FastAPI
import uvicorn

app = FastAPI()

@app.get("/")
def home():
    return {"message": "Hello from inside Docker!"}

if __name__ == "__main__":
    uvicorn.run("server:app", host="0.0.0.0", port=8000, reload=False)
```

```dockerfile
# Base image
FROM python:3.11-slim

# Set working directory
WORKDIR /app

# Copy only dependency file first (for caching)
COPY requirements.txt .

# Install dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Copy the rest of the application
COPY ./server.py .

# Expose application port (optional; for documentation)
EXPOSE 8000

# Default command
ENTRYPOINT ["python", "server.py"]
```

Under the Hood:

- Docker parses each Dockerfile instruction
- Each instruction → new layer (overlayfs snapshot)
- Layers are stored via containerd snapshotter
- BuildKit uses cache to skip unchanged steps

runc sets up:

- Namespaces (PID, NET, MNT, IPC, UTS, USER)
- cgroups (CPU, Memory, IO limits)
- OverlayFS mounts for the filesystem

```sh
# build image
docker build -t web-server .

# Inspect layers
docker history web-server:latest

# Running container
docker run -p 8000:8000 --name my-web-server -d web-server:latest

curl localhost:8000

# Example: see container PID namespace
docker inspect my-web-server --format '{{.State.Pid}}'

# Inspect namespaces manually
lsns | grep $(docker inspect my-web-server --format '{{.State.Pid}}')
```

## Docker Image Architecture & Layer Caching

### Image manifest & Layer structure

Docker images are built from layers

Layers created:

1. FROM python:3.11-slim → base image layer
2. WORKDIR /app → metadata layer
3. COPY requirements.txt . → adds file layer
4. RUN pip install ... → installs dependencies layer
5. COPY . . → app code layer
6. CMD [...] → config layer

```sh
# .RootFS.Layers lists sha256 hashes of each layer
docker inspect nginx:latest --format '{{json .RootFS.Layers}}' | jq

# explain the layers
docker history myapp:latest
```

### Caching behavior in builds

- Docker caches layers to reduce rebuild time
- Only layers after changes are rebuilt

### Reproducibility & determinism

builds may differ like this:

```sh
# non-deterministic
RUN apt-get update && apt-get install -y python3

# deterministic
RUN apt-get update && apt-get install -y python3=3.12.0-1
```

### Multi-stage builds

Multi-stage builds separate build environment from final runtime, reducing final image size.

```dockerfile
# Stage 1: Build
FROM golang:1.21 AS builder
WORKDIR /app
COPY . .
RUN go build -o myapp .

# Stage 2: Runtime
FROM alpine:3.22.2
WORKDIR /app
COPY --from=builder /app/myapp .
CMD ["./myapp"]
```

Benefits:

- Only the final binary is included → smaller image
- Build dependencies (golang SDK) not shipped
- Layers for the build stage are not carried over

Inspect final image size:

```sh
docker images
```

## Docker BuildKit vs Classic Builder

Docker originally used a classic (legacy) builder, which was simple but slow and limited.
BuildKit is the next-generation build engine introduced to solve these limitations.

Think of it like this:

- Classic Builder = old single-threaded compiler
- BuildKit = modern parallel, cached, secure build system

## Understanding the OCI Ecosystem

## OCI & Runtime Architecture

1. OCI Image Spec

How an image is structured
Layers, manifests, configs
Digest/sha256 for immutability
All registries and runtimes follow this.

2. OCI Runtime Spec

How to launch a container
Process lifecycle
cgroups & namespaces configuration
JSON bundle format (config.json)

3. runc (Low-Level Runtime)

Lightweight executable that actually starts a container which executes containers using namespaces + cgroups

- Created by Docker, donated to OCI
- Very small, secure, standard

Responsibilities:

- Setup namespaces (PID, NET, MNT…)
- Setup cgroups (CPU, memory, I/O limits)
- Launch the container process (PID 1)

4. containerd

> It's a container runtime daemon written in Go which provides APIs for pulling images, managing snapshots, and running containers.

Handles:

- Pulling/Pushing images
- Snapshotting (filesystem layers like OverlayFS, btrfs, zfs)
- Launching containers via runc
- Used internally by Docker and Kubernetes.
- Default runtime for Kubernetes (via CRI)

containerd = brains
runc = executor

Engines uses containerd:
Docker
Kubernetes (directly)
NerdCTL

Engines does NOT use containerd:
Podman
CRI-O

5. CRI (Container Runtime Interface)

Used by Kubernetes.
Kubernetes ↔ CRI ↔ containerd
or
Kubernetes ↔ CRI ↔ CRI-O
K8s does not talk to Docker directly anymore.

6. ORAS: OCI registry artifacts (non-container files)

OCI registry standard for storing any files, not just container images.

Examples:

- Helm charts
- WASM binaries
- SBOMs (Software Bill of Materials)

### How They Work Together

You type `docker run my-app`.

1. Docker daemon talks to containerd to:
    - Pull the image
    - Manage its layers
    - Prepare filesystem and resources

2. containerd calls runc to:
    - Start the process
    - Apply isolation (namespaces)
    - Limit resources (cgroups)
    - The container starts, fully isolated, and running your app.

+---------------------+
|       Docker CLI     |  <-- You
+---------------------+
          |
          v
+---------------------+
|      containerd      |  <-- Manages images & lifecycle
+---------------------+
          |
          v
+---------------------+
|        runc         |  <-- Runs container with isolation
+---------------------+
          |
          v
+---------------------+
| Linux Kernel        |  <-- Namespaces, cgroups, overlayFS
+---------------------+
