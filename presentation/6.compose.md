# Compose

Docker Compose is the developer’s orchestration tool for running multi-container applications locally.

It lets you define services, networks, volumes, and configs in a single declarative YAML file.

## Compose File Structure (compose.yml)

Key top-level objects:

- services
- volumes
- networks
- configs
- secrets

Directory strcuture:

```txt
project/
├── docker-compose.yml
└── web/
    ├── Dockerfile
    └── app/
        └── main.py
        └── requirements.txt
```

```yaml
services:
  web:
    build: ./web
    container_name: demo_web
    ports:
      - "8000:8000"
    depends_on:
      - redis
    environment:
      REDIS_HOST: redis
      REDIS_PORT: 6379
    volumes:
      - ./web/app:/app   # bind mount (live code reload)
      - web_logs:/var/log/web  # named volume
    networks:
      - backend

  redis:
    image: redis:7.2
    container_name: demo_redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data   # named volume
    networks:
      - backend

volumes:
  redis_data:     # Named volume for persistent Redis storage
  web_logs:       # Named volume for web logs

networks:
  backend:
    driver: bridge
```

```dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY app/requirements.txt .

RUN pip install --no-cache-dir -r requirements.txt

COPY app .

ENTRYPOINT ["uvicorn", "main:app"]

CMD ["--host", "0.0.0.0", "--port", "8000"]
```

```txt
fastapi==0.100.1
uvicorn==0.23.2
redis==5.0.1
```

```python
from fastapi import FastAPI
import redis
import os

app = FastAPI()

r = redis.Redis(
    host=os.getenv("REDIS_HOST", "redis"),
    port=int(os.getenv("REDIS_PORT", 6379)),
    decode_responses=True
)

@app.get("/")
def read_root():
    return {"message": "Hello from FastAPI!"}

@app.get("/hits")
def hits():
    count = r.incr("hits")
    return {"hits": count}
```

```sh
docker compose up -d

curl localhost:8000
```
